# 13. 스레드 동기화 기법

## 스레드 동기화

### 두가지 관점에서의 스레드 동기화

#### 실행순서의 동기화

예를 들어 A스레드가 계산한 결과를 B그레드가 받아서 출력하는 경우, 반드시 A스레드가 먼저 실행을 완료해야 함. 즉, 스레드의 실행순서를 정의하고, 이 순서에 반드시 다르도록 하는 것

####  메모리 접근에 대한 동기화

한 순간에 하나의 스레드만 접근해야 하는 메모리 영역이 존재함.(데이터 영역과 힙 영역)

실행의 순서가 중요한 상황이 아니고, 한 순간에 하나의 스레드만 접근하면 되는 상황



### 스레드 동기화에 있어서의 두가지 방법

- 유저 모드 동기화 - 동기화가 진행되는 과정에서 커널의 힘을 빌리지 않는 동기화 기법 -> 동기화를 위해 커널 모드로의 전환이 불필요하기 때문에 성능상의 이점이 있음(기능상의 제한 존재)
- 커널 모드 동기화 - 커널에서 제공하는 동기화 기능을 활용하는 방법 -> 동기화에 관련된 함수가 호출될 때마다 커널 모드로의 변경이 필요하고, 성능의 저하로 이어지게 됨 but 유저 모드 동기화에서 제공하지 못하는 기능을 제공받을 수 있음



## 임계 영역(Critical Section)접근 동기화

### 임계 영역

연산을 둘 이상의 스레드가 동시에 실행할 경우 문제가 발생할 수 있는 코드 블록

### Windows에서 제공하는 동기화 기법

1. 크리티컬 섹션 기반의 동기화 - 유저 모드 동기화
   메모리 접근 동기화에 사용

2. 인터락 함수 기반의 동기화 - 유저 모드 동기화

   메모리 접근 동기화에 사용

3. 뮤텍스 기반의 동기화 - 커널 모드 동기화

   메모리 접근 동기화에 사용

4. 세마포어 기반의 동기화 - 커널 모드 동기화

   메모리 접근 동기화에 사용

5. 이름있는 뮤텍스 기반의 프로세스 동기화 - 커널 모드 동기화

   프로세스간 동기화에 사용

6. 이벤트 기반의 동기화 - 커널 모드 동기화

   실행순서 동기화에 사용



## 유저 모드의 동기화

### 크리티컬 섹션 기반의 동기화

1. 크리티컬 섹션 오브젝트를 만들고(CRITICAL_SECTION 객체 선언) 초기화(InitializeCriticalSection)
2. 처리 권한 획득 함수 실행 (EnterCriticalSection)
3. 만약, 다른 스레드에 의해 해당 함수가 실행된 상태라면 호출한 함수는 블로킹 됨
4. 다른 스레드가 크리티컬 섹션 오브젝트가 반환하면 블로킹 상태를 빠져나오게 됨
5. LeaveCriticalSection함수를 통해 크리티컬 섹션 오브젝트 반환

### 인터락 함수 기반의 동기화

인터락 함수는 함수 내부적으로 한 순간 하나의 스레드에 의해서만 실행되도록 동기화되어있음

- InterlockedIncrement함수와 InterlockedDecrement함수는 원자적 접근을 보장하는 함수
- volatile 키워드 - 코드를 컴파일하는 과정에서 코드의 최적화를 수행하는데, 이를 하지 말라는 키워드
- volatile 키워드2 - 메모리에 직접 연산하라는 키워드
- volatile 키워드3 - 절대로 캐쉬되지 않음. 따라서, 데이터를 특정 주소에 저장하는 순간 메모리에 저장이 바로 이뤄진다



## 커널 모드 동기화

### 뮤텍스 기반의 동기화

크리티컬 섹션 오브젝트에 해당하는 뮤텍스 오브젝트(뮤텍스)가 사용됨.

1. CreateMutex함수를 호출하여 뮤텍스 오브젝트 생성(커널 오브젝트이므로 핸들값 반환)
2. 뮤텍스는 누군가에 의해 획득이 가능할 때 Signaled상태에 놓임
3. 따라서, WaitForSingleObject함수를 임계 영역 진입을 위한 뮤텍스 획득의 용도로 사용(뮤텍스가 Non-Signaled상태가 됨)
4. ReleaseMutex함수를 통해 뮤텍스를 반환하여 Signaled상태로 변경

### 세마포어 기반의 동기화

뮤텍스와 세마포어의 차이 - Count기능!

뮤텍스 - 임계 영역에 접근 가능한 스레드 개수를 조절하는 기능이 없다

세마포어 - 임계 영역에 접근 가능한 스레드 개수를 조절할 수 있다

1. 세마포어를 생성함
2. WaitForSingleObject함수가 호출될 때마다 카운터가 하나씩 감소하며 함수를 반환함
3. 카운터가 0인 상태에서 WaitForSingleObject함수가 호출되면 블로킹 상태로 진입한다
4. 스레드가 끝나면 ReleaseSemaphore함수를 호출하여 반환한다.

### 이름있는 뮤텍스 기반의 프로세스 동기화

- 이름있는 뮤텍스(Named Mutex) - 뮤텍스에 이름을 붙여 생성할 경우
- 이름있는 세마포어(Named Semaphore) - 세마포어에 이름을 붙여 생성할 경우
- 뮤텍스는 커널 오브젝트이므로, 커널이 관리하기 때문에 각기 다른 프로세스에서 접근이 가능하다.
- 그러나, 앞서 설명했듯 핸들의 유효성으로 인해 서로 다른 프로세스는 독립적인 핸들 테이블을 갖고 있기 때문에 다른 프로세스의 커널 오브젝트에 접근이 불가하다.
- 이에 따라 Windows라는 운영체제 내에서 유일한 이름을 할당하여 이름있는 뮤텍스를 만들어 서로 다른 프로세스에서 같은 뮤텍스를 통해 동기화를 할 수 있다.

### 뮤텍스의 소유와 WAIT_ABANDONED

WAIT_ABANDONED - WaitForSingleObject 함수의 반환값 중 하나.

- **뮤텍스는 획득한 스레드가 직접 반환하는 것이 원칙**
- **그러나 세마포어와 그 이외의 동기화 오브젝트는 다른 스레드가 대신 반환해 줘도 문제가 되지 않음**
- WAIT_ABANDONED가 반환되는 상황 - Windows는 스레드의 상태와 뮤텍스의 상태를 예의주시하기 때문에 뮤텍스를 반환하지 않고 스레드가 종료되었음을 감지한다. 이 때, 정상적인 방법으로 반환이 불가능한 뮤텍스를 대신 반환해 주고, 다음 대기자인 스레드가 뮤텍스를 소유할 수 있게 도와주면서 반환하는 값

