# 12. 스레드의 생성과 소멸

## 동시 접근에 있어서의 문제점

1. 스레드 A와 B가 각각 Total이란 전역변수를 각각 4와 6 더한다고 하자.
2. 프로그램이 실행되어 A가 Total에 4를 더했고, 해당 값이 메모리에 저장되기 전에 레지스터에 저장되었다.
3. 이 때, 컨텍스트 스위칭이 발생하여 B가 6을 더한 후, 해당 값이 메모리에 저장되어 Total은 6이 되었다.
4. 이후 다시 컨텍스트 스위칭이 발생하여 레지스터에 있던 Total = 4가 메모리에 저장되어 최종적으로 Total은 4가 되었다.

위와 같은 문제를 Data Racing이라 한다.



## ANSI 표준 C 라이브러리와 스레드

- 초기에 표준 C 라이브러리가 구현될 당시만 해도 스레드에 대한 고려가 전혀 이뤄지지 않았다.


- 따라서, 멀티 스레드 기반으로 프로그램을 구현하게 되면, 동일한 메모리 영역을 동시 접근하는 불상사가 발생할 수 있다.


- 마이크로소프트에서는 이에 따라 멀티스레드에 안전한 ANSI 표준 라이브러리를 제공함
- 프로젝트 속성에서 런타임 라이브러리를 ANSI라이브러리로 바꾸면 된다
- 이에 따라, CreateThread가 아닌 _beginthreadex 함수를 사용하는데 이를 통해 독립적인 메모리 블록을 할당할 수 있다.
- 각 스레드를 위해 메모리를 할당하기 때문에 종료 시에 할당한 메모리를 반환해야 한다. 따라서 스레드를 반환할 때는 return문을 이용하자!



## 스레드의 상태 컨트롤

- Windows는 상태가 변화하는 주체가 프로세스가 아니라 스레드임
- 따라서, 기본적인 Ready-Running-Blocked상태는 동일함
- Suspend - 스레드를 Blocked상태로 만드는 함수
- ResumeThread - 스레드를 Ready상태로 만드는 함수
- Suspend Count - 스레드의 커널 오브젝트에 존재하며 SuspendThread함수의 호출 빈도를 기록



## 스레드의 우선순위 컨트롤

| Priority                     | Meaning    |
| ---------------------------- | ---------- |
| THREAD_PRIORITY_LOWEST       | -2         |
| THREAD_PRIORITY_BELOW_NORMAL | -1         |
| THREAD_PRIORITY_NORMAL       | 0(Default) |
| THREAD_PRIORITY_ABOVE_NORMAL | +1         |
| THREAD_PRIORITY_HIGHEST      | +2         |

- 스레드의 우선순위는 프로세스의 기준 우선순위와 스레드의 상대적 우선순위의 조합으로 결정됨
- 스레드의 최종 우선순위 = 프로세스의 우선순위 + 스레드의 상대적 우선순위